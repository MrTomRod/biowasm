diff --git a/Makefile b/Makefile
index 4118616..8b32c80 100644
--- a/Makefile
+++ b/Makefile
@@ -44,8 +44,8 @@ all:$(PROG)
 
 extra:all $(PROG_EXTRA)
 
-minimap2:main.o libminimap2.a
-		$(CC) $(CFLAGS) main.o -o $@ -L. -lminimap2 $(LIBS)
+$(PROGRAM):main.o libminimap2.a
+		$(CC) $(CFLAGS) main.o -o ../build/$@.js -L. -lminimap2 $(LIBS) $(WASM_FLAGS)
 
 minimap2-lite:example.o libminimap2.a
 		$(CC) $(CFLAGS) $< -o $@ -L. -lminimap2 $(LIBS)
diff --git a/Makefile.simde b/Makefile.simde
index ae7ff4a..636c733 100644
--- a/Makefile.simde
+++ b/Makefile.simde
@@ -36,8 +36,8 @@ all:$(PROG)
 
 extra:all $(PROG_EXTRA)
 
-minimap2:main.o libminimap2.a
-		$(CC) $(CFLAGS) main.o -o $@ -L. -lminimap2 $(LIBS)
+$(PROGRAM):main.o libminimap2.a
+		$(CC) $(CFLAGS) main.o -o ../build/$@.js -L. -lminimap2 $(LIBS) $(WASM_FLAGS)
 
 minimap2-lite:example.o libminimap2.a
 		$(CC) $(CFLAGS) $< -o $@ -L. -lminimap2 $(LIBS)
diff --git a/kthread.c b/kthread.c
index ffdf940..5117d61 100644
--- a/kthread.c
+++ b/kthread.c
@@ -2,6 +2,7 @@
 #include <stdlib.h>
 #include <limits.h>
 #include <stdint.h>
+#include <stdio.h>
 #include "kthread.h"
 
 #if (defined(WIN32) || defined(_WIN32)) && defined(_MSC_VER)
@@ -53,6 +54,7 @@ static void *ktf_worker(void *data)
 
 void kt_for(int n_threads, void (*func)(void*,long,int), void *data, long n)
 {
+n_threads = 1;
 	if (n_threads > 1) {
 		int i;
 		kt_for_t t;
@@ -99,32 +101,33 @@ static void *ktp_worker(void *data)
 	ktp_worker_t *w = (ktp_worker_t*)data;
 	ktp_t *p = w->pl;
 	while (w->step < p->n_steps) {
-		// test whether we can kick off the job with this worker
-		pthread_mutex_lock(&p->mutex);
-		for (;;) {
-			int i;
-			// test whether another worker is doing the same step
-			for (i = 0; i < p->n_workers; ++i) {
-				if (w == &p->workers[i]) continue; // ignore itself
-				if (p->workers[i].step <= w->step && p->workers[i].index < w->index)
-					break;
-			}
-			if (i == p->n_workers) break; // no workers with smaller indices are doing w->step or the previous steps
-			pthread_cond_wait(&p->cv, &p->mutex);
-		}
-		pthread_mutex_unlock(&p->mutex);
+printf("ktp_worker: %d %d\n", w->step, p->n_steps);
+		// // test whether we can kick off the job with this worker
+		// pthread_mutex_lock(&p->mutex);
+		// for (;;) {
+		// 	int i;
+		// 	// test whether another worker is doing the same step
+		// 	for (i = 0; i < p->n_workers; ++i) {
+		// 		if (w == &p->workers[i]) continue; // ignore itself
+		// 		if (p->workers[i].step <= w->step && p->workers[i].index < w->index)
+		// 			break;
+		// 	}
+		// 	if (i == p->n_workers) break; // no workers with smaller indices are doing w->step or the previous steps
+		// 	pthread_cond_wait(&p->cv, &p->mutex);
+		// }
+		// pthread_mutex_unlock(&p->mutex);
 
 		// working on w->step
 		w->data = p->func(p->shared, w->step, w->step? w->data : 0); // for the first step, input is NULL
 
 		// update step and let other workers know
-		pthread_mutex_lock(&p->mutex);
+		// pthread_mutex_lock(&p->mutex);
 		w->step = w->step == p->n_steps - 1 || w->data? (w->step + 1) % p->n_steps : p->n_steps;
 		if (w->step == 0) w->index = p->index++;
-		pthread_cond_broadcast(&p->cv);
-		pthread_mutex_unlock(&p->mutex);
+		// pthread_cond_broadcast(&p->cv);
+		// pthread_mutex_unlock(&p->mutex);
 	}
-	pthread_exit(0);
+	// pthread_exit(0);
 }
 
 void kt_pipeline(int n_threads, void *(*func)(void*, int, void*), void *shared_data, int n_steps)
@@ -134,6 +137,7 @@ void kt_pipeline(int n_threads, void *(*func)(void*, int, void*), void *shared_d
 	int i;
 
 	if (n_threads < 1) n_threads = 1;
+n_threads = 1;
 	aux.n_workers = n_threads;
 	aux.n_steps = n_steps;
 	aux.func = func;
@@ -150,8 +154,10 @@ void kt_pipeline(int n_threads, void *(*func)(void*, int, void*), void *shared_d
 	}
 
 	tid = (pthread_t*)calloc(n_threads, sizeof(pthread_t));
-	for (i = 0; i < n_threads; ++i) pthread_create(&tid[i], 0, ktp_worker, &aux.workers[i]);
-	for (i = 0; i < n_threads; ++i) pthread_join(tid[i], 0);
+	// for (i = 0; i < n_threads; ++i) pthread_create(&tid[i], 0, ktp_worker, &aux.workers[i]);
+	// for (i = 0; i < n_threads; ++i) pthread_join(tid[i], 0);
+	ktp_worker(&aux.workers[0]);
+
 	free(tid); free(aux.workers);
 
 	pthread_mutex_destroy(&aux.mutex);
diff --git a/main.c b/main.c
index 3c62576..06fb56e 100644
--- a/main.c
+++ b/main.c
@@ -121,7 +121,7 @@ int main(int argc, char *argv[])
 	ketopt_t o = KETOPT_INIT;
 	mm_mapopt_t opt;
 	mm_idxopt_t ipt;
-	int i, c, n_threads = 3, n_parts, old_best_n = -1;
+	int i, c, n_threads = 1, n_parts, old_best_n = -1;
 	char *fnw = 0, *rg = 0, *junc_bed = 0, *s, *alt_list = 0;
 	FILE *fp_help = stderr;
 	mm_idx_reader_t *idx_rdr;
@@ -294,6 +294,12 @@ int main(int argc, char *argv[])
 			if (*s == ',') opt.e2 = strtol(s + 1, &s, 10);
 		}
 	}
+
+	if(n_threads > 1) {
+		fprintf(stderr, "[ERROR]\033[1;31m Multithreading not supported in this environment.\033[0m\n");
+		return 1;
+	}
+
 	if ((opt.flag & MM_F_SPLICE) && (opt.flag & MM_F_FRAG_MODE)) {
 		fprintf(stderr, "[ERROR]\033[1;31m --splice and --frag should not be specified at the same time.\033[0m\n");
 		return 1;
